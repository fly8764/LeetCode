'''
dfs:直接根据定义即可，但是要注意标记，防止重复计算
bfs：标记时刻要注意，要在入队时，里面标记，而不是出队时才标记，出队时再标记，会导致很多重复的计算；
'''
#dfs 比 bfs 要快
class Solution:
    #dfs 比 bfs 要快
    def dfs(self,x,y):
        #深度优先搜索
        # self.marked[x][y] = 1
        for item in self.dir:
            x_new = x + item[0]
            y_new = y + item[1]
            if 0 <= x_new< self.m and 0 <= y_new < self.n and \
                not self.marked[x_new][y_new] and self.grid[x_new][y_new] =='1':
                self.marked[x_new][y_new] = 1
                self.dfs(x_new,y_new)

    def numIslands(self, grid):
        self.m = len(grid)
        if self.m  < 1:
            return 0
        self.n = len(grid[0])
        self.grid = grid

        self.dir = [[0,1],[0,-1],[-1,0],[1,0]]
        self.marked = [[0]*self.n for _ in range(self.m)]
        cnt = 0
        for i in range(self.m):
            for j in range(self.n):
                if not self.marked[i][j] and grid[i][j] == '1':
                   cnt += 1
                   self.marked[i][j] = 1
                   self.dfs(i,j)
        return cnt

    # def bfs(self,start_x,start_y):
    #     #要注意标记的时间，入队里面标记，否则会造成很多重复地操作
    #     #广度优先遍历，寻找邻接点，知道找不到，active为空，岛屿数加1
    #     #队列必须先进先出
    #     active = [[start_x,start_y]]
    #     while active:
    #         p = active.pop(0)
    #         x,y = p[0],p[1]
    #         # 标记这个点，代表已经走过
    #         # self.marked[x][y] = 1
    #         #搜集邻域节点
    #         for item in self.dir:
    #             x_new = x + item[0]
    #             y_new = y + item[1]
    #             #邻域节点为1，且没有被访问过
    #             if 0 <= x_new < self.m and 0 <= y_new < self.n and \
    #                     self.grid[x_new][y_new] == '1' and not self.marked[x_new][y_new]:
    #                 active.append([x_new, y_new])
    #                 #这里标记要注意，最好在 入队时就立马 标记；要是等到出队时再标记，会造成很多重复地计算；
    #                 #因为，入队时如果不标记，在这个点未出队时，其他点还可能访问到这个点，发现没有被标记，就会又把
    #                 #这个点入队，重复操作；队里中同时出现两个或多个点，当这个点出队时，也会有这样的重复点出现
    #                 self.marked[x_new][y_new] = 1
    #     self.cnt += 1

    # def numIslands(self, grid):
    #     self.cnt = 0
    #     self.m = len(grid)
    #     if self.m  < 1:
    #         return 0
    #     self.n = len(grid[0])
    #     self.grid = grid
    #
    #     self.dir = [[0,1],[0,-1],[-1,0],[1,0]]
    #     self.marked = [[0]*self.n for _ in range(self.m)]
    #     for i in range(self.m):
    #         for j in range(self.n):
    #             if not self.marked[i][j] and grid[i][j] == '1':
    #                 self.marked[i][j] = 1
    #                 self.bfs(i,j)
    #
    #     return self.cnt


if __name__ == '__main__':
    so = Solution()
    grid1 = [['1','1','1','1','0'],
            ['1','1','0','1','0'],
            ['1','1','0','0','0'],
            ['0','0','0','0','0']]

    grid2 = [['1','1','0','0','0'],
             ['1','1','0','0','0'],
             ['0','0','1','0','0'],
             ['0','0','0','1','1']]

    print(so.numIslands([]))
    print(so.numIslands(grid1)) #3
    print(so.numIslands(grid2)) #3

    grid3 = [["1","1","0","0","0"],
             ["1","1","0","0","0"],
             ["0","0","1","0","0"],
             ["0","0","0","1","1"]]
    print(so.numIslands(grid3))

    grid4 = [["1","1","1","1","1","0","1","1","1","1","1","1","1","1","1","0","1","0","1","1"],
             ["0","1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","0"],
             ["1","0","1","1","1","0","0","1","1","0","1","1","1","1","1","1","1","1","1","1"],
             ["1","1","1","1","0","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
             ["1","0","0","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
             ["1","0","1","1","1","1","1","1","0","1","1","1","0","1","1","1","0","1","1","1"],
             ["0","1","1","1","1","1","1","1","1","1","1","1","0","1","1","0","1","1","1","1"],
             ["1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","0","1","1"],
             ["1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","1","1","1","1"],
             ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
             ["0","1","1","1","1","1","1","1","0","1","1","1","1","1","1","1","1","1","1","1"],
             ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
             ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
             ["1","1","1","1","1","0","1","1","1","1","1","1","1","0","1","1","1","1","1","1"],
             ["1","0","1","1","1","1","1","0","1","1","1","0","1","1","1","1","0","1","1","1"],
             ["1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","1","0"],
             ["1","1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","0","0"],
             ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
             ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
             ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"]]
    print(so.numIslands(grid4))



